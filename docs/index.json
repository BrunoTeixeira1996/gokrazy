[
{
	"uri": "https://gokrazy.org/quickstart/",
	"title": "Quickstart",
	"tags": [],
	"description": "",
	"content": "Prep: pick a supported device Currently, the Raspberry Pi 4 B is the recommended platform for using gokrazy, but you can find other supported and upcoming platforms.\nPrep: Install Go If you don‚Äôt already have Go installed, install the latest Go version.\nPrep: Install the gokrazy packer Now that you have a working Go installation, install the gokrazy packer (gokr-packer):\ngo install github.com/gokrazy/tools/cmd/gokr-packer@latest Step 1: Insert an SD card Run watch -d1 ls -l '/dev/disk/by-id/*' and insert an SD card. Copy the highlighted device name:\nIn this example, we‚Äôll assume the SD card is accessible as /dev/sdx.\nStep 2: Create a gokrazy instance and overwrite an SD card with gokrazy Create a directory for this gokrazy instance:\nINSTANCE=gokrazy/hello mkdir -p ~/${INSTANCE?} cd ~/${INSTANCE?} To overwrite the entire SD card /dev/sdx with a gokrazy installation running a hello world program, use:\ngokr-packer \\ -overwrite=/dev/sdx \\ -serial_console=disabled \\ github.com/gokrazy/fbstatus \\ github.com/gokrazy/hello \\ github.com/gokrazy/serial-busybox The gokrazy packer builds each specified Go program (e.g. github.com/gokrazy/hello) in a separate build directory, each with its own go.mod file. See Working with Go modules for more details.\nThis is what the above gokrazy packer command looks like in action:\nClick here to show the gokr-packer log output gokrazy packer v0.0.0-20211121205320-688793dda2da on GOARCH=amd64 GOOS=linux Build target: CGO_ENABLED=0 GOARCH=arm64 GOOS=linux Build timestamp: 2021-11-25T09:28:41+01:00 Loading system CA certificates from /etc/ssl/certs/ca-certificates.crt Building 3 Go packages: github.com/gokrazy/fbstatus github.com/gokrazy/hello github.com/gokrazy/serial-busybox [done] in 0.48s Feature summary: use PARTUUID: true use GPT PARTUUID: true 2021/11/25 09:28:42 partitioning /dev/sdx (GPT + Hybrid MBR) 2021/11/25 09:28:42 Using sudo to gain permission to format /dev/sdx 2021/11/25 09:28:42 If you prefer, cancel and use: sudo setfacl -m u:${USER}:rw /dev/sdx 2021/11/25 09:28:42 device holds 15931539456 bytes Creating boot file system Kernel directory: /home/michael/go/src/github.com/gokrazy/kernel EEPROM update summary: pieeprom.upd (sig 5a07872332) recovery.bin vl805.bin (sig 3a46dda0da) [done: creating boot file system] in 0.11s, 66 MiB MBR summary: LBAs: vmlinuz=52150 cmdline.txt=135442 PARTUUID: 2e18c40c Creating root file system [done: creating root file system] in 0.26s If your applications need to store persistent data, unplug and re-plug the SD card, then create a file system using e.g.: mkfs.ext4 /dev/disk/by-partuuid/60c24cc1-f3f9-427a-8199-2e18c40c0004 To boot gokrazy, plug the SD card into a Raspberry Pi 3 or 4 (no other models supported) Build complete! To interact with the device, gokrazy provides a web interface reachable at: http://gokrazy:\u0026lt;automatically-generated-random-password\u0026gt;@gokrazy/ In addition, the following Linux consoles are set up: 1. foreground Linux framebuffer console on HDMI It is safe to unplug your SD card once gokr-packer returns.\nStep 3: Boot gokrazy After booting from this SD card, your device will:\ndisplay system status on the monitor connected via HDMI, if any obtain an IP address for hostname ‚Äúgokrazy‚Äù via DHCP (IPv4) and SLAAC (IPv6) synchronize the clock using NTP expose a password-authenticated web interface on private IP addresses\n(the default password is automatically generated and can be recovered from ~/.config/gokrazy/http-password.txt on Linux or from ~/Library/Application\\ Support/gokrazy/http-password.txt on macOS/Darwin) supervise all installed programs (only the hello world program in this example) To interact with your device, you can:\nOpen the gokrazy web interface in your browser (easiest option) Attach a serial console (see below) Install breakglass via the gokrazy packer, which allows you to start an interactive SSH session. Congratulations! üéâ You now have a working gokrazy installation!\nNext, see the Configuration guide for details on how to use other programs.\nOptional: Using the serial console If you prefer the serial console, you can optionally connect a serial adapter to the Raspberry Pi and remove the -serial_console=disabled flag to make the primary Linux console end up on the serial console.\nWhen pressing Enter on the serial console, gokrazy will interactively start either:\n/tmp/serial-busybox/ash (provided by the serial-busybox package) /perm/sh, if present (supplied by you, the user) "
},
{
	"uri": "https://gokrazy.org/packages/showcase/",
	"title": "Showcase",
	"tags": [],
	"description": "",
	"content": "Written for gokrazy The following third-party programs specifically target gokrazy.\nTo get your program listed here, just send us a pull request.\nscan2drive scan2drive is an appliance (with a web interface) that scans paper documents üìÑ from a scanner üñ®Ô∏è as PDFs to Google Drive for full-text search.\nrouter7 router7 is a small home internet router completely written in Go.\nhmgo hmgo is a minimal HomeMatic house automation central control unit replacement (specific to stapelberg‚Äôs home network).\nbeatbox beatbox is a Raspberry Pi 3-based toy that combines a Mir:ror and NFC figurines for playing music stored on the device or directly from Spotify.\nconsrv consrv is a Raspberry Pi 4-based appliance that provides a basic SSH to serial console bridge for accessing remote devices.\nkrazyotelcol krazyotelcol is an appliance running the OpenTelemetry Collector, a vendor-agnostic implementation on how to receive, process and export telemetry data.\nRestic\u0026rsquo;s rest-server Rest Server is a high performance HTTP server that implements restic\u0026rsquo;s REST backend API. Running it requires some setup and other configurations which are available in this blog post.\nSuccessfully tested The following third-party programs have been successfully used with gokrazy but might require additional setup:\nPrometheus Prometheus is a monitoring and alerting system built on a time series database.\nThe Prometheus node exporter exposes various metrics of the system on which it is running for use with the prometheus monitoring and alerting system.\nThe Prometheus blackbox exporter allows blackbox probing of endpoints over HTTP, HTTPS, DNS, TCP and ICMP for use with the prometheus monitoring and alerting system.\nGrafana Grafana is an open platform for beautiful analytics and monitoring.\nMinIO MinIO is a high performance, S3-compatible, cloud native object storage service.\nSee also Available packages ‚Üí MinIO.\nNo Go software for your idea? You can prototype your idea by temporarily using existing software to close the gap. See Prototyping.\n"
},
{
	"uri": "https://gokrazy.org/platforms/",
	"title": "Supported platforms",
	"tags": [],
	"description": "",
	"content": "Recommended: Raspberry Pi 4 B gokrazy development happens primarily on the Raspberry Pi 4 B.\nAll currently supported platforms Raspberry Pi 4 B PC Engines APU Raspberry Pi Zero 2 W Raspberry Pi 3 B and 3 B+ Continuous Integration (CI) Appliances which are marked in bold are tested in the CI setup on real hardware and gate new kernel and firmware versions, and hence can be considered supported.\nNon-bold appliances are supported in a best-effort way, meaning they might be temporarily broken at HEAD.\nThe leading github.com in front of package import paths has been omitted for space reasons.\nTarget Hardware GOARCH Kernel package Firmware package Appliances apu2c4 apu2c4 amd64 rtr7/kernel rtr7/kernel gokrazy/bakery/cmd/bake rtr7/router7 x86-64 qemu amd64 rtr7/kernel rtr7/kernel gokrazy/bakery/cmd/bake rpi4b raspi4b arm64 gokrazy/kernel gokrazy/firmware gokrazy/bakery/cmd/bake\nstapelberg/hmgo\nstapelberg/scan2drive rpi3b raspi3b arm64 gokrazy/kernel gokrazy/firmware gokrazy/bakery/cmd/bake rpi3b+ raspi3b+ arm64 gokrazy/kernel gokrazy/firmware gokrazy/bakery/cmd/bake rpizero2w raspizero2w arm64 gokrazy/kernel gokrazy/firmware gokrazy/bakery/cmd/bake Performance The JPEG encoding column is the result of running scan2drive‚Äôs neonjpeg micro-benchmark.\nHardware JPEG encoding raspi4b 0.69s raspi3b 1.22s raspizero2w 1.47s Power Usage These power measurements were done using a HomeMatic HM-ES-PMSw1-Pl power switch with measurement feature. The Raspberry Pi 4 was using the original Raspberry Pi power supply, the others were measured with a random USB power supply.\nHardware Power Usage apu2c4 4.0W raspi3b 1.5W raspi3b+ 2.5W raspi4b 2.8W raspizero2w 0.8W Hardware Support Hardware WiFi Bluetooth apu2c4 needs card, untested needs dongle, untested raspi3b open or WPA-PSK limited raspi3b+ open or WPA-PSK limited raspi4b open or WPA-PSK limited raspizero2w open or WPA-PSK limited Community-supported platforms Independently from the official gokrazy kernel and firmware, people of our community provide alternative kernels and firmwares, in order to run gokrazy on unsupported platform or to provide new features. They may not be as thoroughly tested as the official platforms. Please report any issue to their respective repostitory.\nCommunity-supported Raspberry Pi OS 32-bit kernel/firmware gokrazy‚Äôs official kernel is an upstream Linux kernel (directly from kernel.org) that supports ARMv8 64-bit machines, meaning the Raspberry Pi 3 and newer. The primary reason for using the upstream kernel is so that security fixes can be immediately pulled in without having to wait on third parties.\nThe community-supported github.com/gokrazy-community/kernel-rpi-os-32 kernel on the other hand is the Raspberry Pi OS kernel (provided by the Raspberry Pi foundation) that supports ARMv6 32-bit machines, which includes all Raspberry Pis. The corresponding firmware for this kernel is github.com/gokrazy-community/firmware-rpi.\nThis kernel might generally be useful if you want to use hardware peripherals that are not yet supported in the upstream Linux kernel.\nThis kernel is the only choice for you if you have a Raspberry Pi that‚Äôs older than the Raspberry Pi 3, but you still want to use gokrazy with it.\nCommunity-supported Odroid XU4/HC1/HC2 Odroid XU4/HC1/HC2 is based on a Samsung Exynos 5422 SOC (4 ARM Cortex-A15 cores and 4 ARM Cortex-A7 cores) and has been on the market since ~2016. HC1 and HC2 variants support installing a 2.5\u0026rsquo;/3.5\u0026rsquo; hard drive on board.\nKernel for these devices is available at github.com/anupcshan/gokrazy-odroidxu4-kernel. This package contains a recent kernel, U-boot and some binary blobs that are required to initiate the boot process. It has been tested against Odroid HC2 hardware with gigabit networking, USB and HDD functional.\nSee github.com/anupcshan/odroidbake for an example on how to create a new disk image.\ngokr-packer \\ -kernel_package=github.com/anupcshan/gokrazy-odroidxu4-kernel \\ -eeprom_package= \\ # Device doesn\u0026#39;t use RPI EEPROM -firmware_package= \\ # No extra firmware package- everything bundled into kernel -device_type=odroidhc1 \\ # To handle MBR boot and define how to layout boot files -serial_console=disabled \\ # list of packages to install "
},
{
	"uri": "https://gokrazy.org/userguide/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": "Configuration After following the Quickstart guide, you should have a working gokrazy installation to further customize.\nThese configuration guides walk you through various topics. If you feel a common use-case should be included here but isn‚Äôt, please file an issue on GitHub.\nConfiguration guides Package config: flags, environment variables, extra files Remote Syslog: sending gokrazy logs over the network Using TLS in untrusted networks Connecting to WiFi networks Using Bluetooth Access permanent data Permanent data backup with the gokrazy rsyncd "
},
{
	"uri": "https://gokrazy.org/packages/",
	"title": "Available packages",
	"tags": [],
	"description": "",
	"content": "Available packages The guides in this chapter show how to set up popular third-party software.\nIf you feel a common program should be included here but isn‚Äôt, please file an issue on GitHub.\nInstalling existing Go software To add an existing Go software to you installation, you just need to indicate the import path of the package to gokr-packer.\nFor instance to install github.com/stapelberg/scan2drive/cmd/scan2drive:\ngokr-packer \\ -overwrite=/dev/sdx \\ github.com/stapelberg/scan2drive/cmd/scan2drive Packages guides Showcase Tailscale VPN Caddy HTTP server MinIO object storage Docker containers "
},
{
	"uri": "https://gokrazy.org/development/",
	"title": "Package development",
	"tags": [],
	"description": "",
	"content": "Package development A gokrazy package corresponds to a Go package (which in turn is part of a Go module). The gokr-packer program is a wrapper around go install.\nTo use the local version of a repository, use the replace directive of go.mod.\nDevelopment guides Process interface / requirements Controlling a GPIO input/output pin Working with Go modules Non-Go Prototyping "
},
{
	"uri": "https://gokrazy.org/userguide/package-config/",
	"title": "Package config: flags, environment variables, extra files",
	"tags": [],
	"description": "",
	"content": "gokrazy will arrange for each included package to be started at boot. For example, given the following packer command:\ngokr-packer \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/breakglass \\ github.com/gokrazy/serial-busybox ‚Ä¶gokrazy will start the hello, breakglass and serial-busybox programs.\nThis article shows how you can configure different aspects of individual packages.\nEach bit of configuration lives in its own directory:\nflags for Command-line flags env for Environment variables buildflags for Go build flags extrafiles for Extra files Within these directories, create a directory named after the package import path, then place your configuration in a text file: flags.txt, env.txt or buildflags.txt.\nCommand-line flags The breakglass package provides emergency/debugging access to a gokrazy installation.\nTo enable SSH port forwardings to localhost, set the -forward flag to loopback:\nmkdir -p flags/github.com/gokrazy/breakglass echo \u0026#39;-forward=loopback\u0026#39; \u0026gt; flags/github.com/gokrazy/breakglass/flags.txt Environment variables Environment variables such as the Go runtime‚Äôs GODEBUG variable can be set as follows:\nmkdir -p env/github.com/gokrazy/breakglass echo \u0026#39;GODEBUG=gctrace=1\u0026#39; \u0026gt; env/github.com/gokrazy/breakglass/env.txt Go build flags If you want to influence the build of the package at image-creation time (as opposed to runtime), you can specify flags to be passed to the Go build invocation.\nThis example overwrites the value of the world variable using the -X linker flag, which is a common technique to embed version information:\nmkdir -p buildflags/github.com/gokrazy/hello echo \u0026#39;-ldflags=-X main.world=Welt\u0026#39; \u0026gt; buildflags/github.com/gokrazy/hello/buildflags.txt Extra files If your program needs extra files to be present in gokrazy‚Äôs root file system image at a specific location, you can add them with the extrafiles mechanism:\nmkdir -p extrafiles/github.com/caddyserver/caddy/v2/cmd/caddy/etc/caddy cat \u0026gt; extrafiles/github.com/caddyserver/caddy/v2/cmd/caddy/etc/caddy/Caddyfile \u0026lt;\u0026lt;\u0026#39;EOT\u0026#39; http://:80 { root * /tmp file_server browse } EOT "
},
{
	"uri": "https://gokrazy.org/development/process-interface/",
	"title": "Process interface / requirements",
	"tags": [],
	"description": "",
	"content": "Process supervision You can find the corresponding code in func gokrazy.supervise.\ngokrazy‚Äôs init process (pid 1) supervises all the binaries the user specified via gokr-packer flags.\nMore specifically, gokrazy:\nStarts your binary using Go‚Äôs os/exec.Command API. unshare(CLONE_NEWNS) is used so that each process operates in its own mount namespace. The stdout and stderr file descriptors are hooked up to a ring buffer and can be viewed via gokrazy‚Äôs web interface. Extra command-line flags or environment variables can be specified using per-package configuration. When your binary‚Äôs process exits, gokrazy restarts it! If the process exits with status code 0 (or 125), gokrazy will stop supervision. Exiting immediately with status code 0 when the GOKRAZY_FIRST_START=1 environment variable is set means ‚Äúdon‚Äôt start the program on boot‚Äù Environment variables gokrazy sets the HOME environment variable to HOME=/perm/\u0026lt;cmd\u0026gt;, where \u0026lt;cmd\u0026gt; is the name of your binary. For example, tailscale.com/cmd/tailscaled is started with HOME=/perm/tailscaled.\nWhen your binary is first started, gokrazy sets the GOKRAZY_FIRST_START=1 environment variable.\nPrivilege dropping / security An easy way to implement privilege dropping in Go is to re-execute the process with syscall.SysProcAttr fields set. For example, this is how you would drop privileges to user nobody (uid/gid 65534):\n// mustDropPrivileges re-executes the program in a child process, // dropping root privileges to user nobody. func mustDropPrivileges() { if os.Getenv(\u0026#34;NTP_PRIVILEGES_DROPPED\u0026#34;) == \u0026#34;1\u0026#34; { return } cmd := exec.Command(os.Args[0]) cmd.Env = append(os.Environ(), \u0026#34;NTP_PRIVILEGES_DROPPED=1\u0026#34;) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = \u0026amp;syscall.SysProcAttr{ Credential: \u0026amp;syscall.Credential{ Uid: 65534, Gid: 65534, }, } log.Fatal(cmd.Run()) } Examples:\ngithub.com/gokrazy/gokrazy/cmd/ntp is a rather involved example which retains the CAP_SYS_TIME capability in the child process github.com/gokrazy/rsync uses Linux mount namespaces and constructs a file system with read-only bind mounts of the configured rsync modules "
},
{
	"uri": "https://gokrazy.org/packages/tailscale/",
	"title": "Tailscale VPN",
	"tags": [],
	"description": "",
	"content": "Tailscale‚Äôs website reads:\nA secure network that just works\nZero config VPN. Installs on any device in minutes, manages firewall rules for you, and works from anywhere.\ngokrazy-based devices are no exception! This guide shows you how to use Tailscale with gokrazy.\nTailscale‚Äôs networking will come in handy when accessing your gokrazy server remotely (no static DHCP leases, port-forwarding and DynDNS required!), or even to secure your communication when gokrazy is connected to an unencrypted WiFi network.\nTailscale currently uses Userspace networking mode on gokrazy, because for tun mode, Tailscale currently requires components that gokrazy does not provide. For accessing the services on your gokrazy installation, the Userspace networking mode works fine, though ü•≥ .\nRequirements Package tailscale.com v1.22.1 or later (latest version used automatically unless you have the package already in go.mod) Volume /perm/ needs to be initialized (instructions use github.com/gokrazy/mkfs to initialize) to persist authentication over reboots. Step 1. set command-line flags We need to specify the following flags for the tailscale to bring up connection (see Package config: flags and environment variables if you‚Äôre unfamiliar with this mechanism):\nOption A: interactive authentication\nmkdir -p flags/tailscale.com/cmd/tailscale cat \u0026gt; flags/tailscale.com/cmd/tailscale/flags.txt \u0026lt;\u0026lt;EOF up EOF Option B: unattended authentication with auth key\nAlternatively, navigate to Tailscale console and open Settings / Keys. Generate auth key.\nInclude the key to tailscale flags:\ncat \u0026gt; flags/tailscale.com/cmd/tailscale/flags.txt \u0026lt;\u0026lt;EOF up --auth-key=tskey-AAAAAAAAAAAA-AAAAAAAAAAAAAAAAAAAAAA EOF Step 2. include the tailscale packages In your gokr-packer invocation (see Quickstart if you don‚Äôt have one yet), include the Tailscale daemon tailscaled and CLI tailscale Go packages:\ngokr-packer \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/mkfs \\ tailscale.com/cmd/tailscaled \\ tailscale.com/cmd/tailscale We include mkfs to automatically initialize a filesystem on the /perm partition on first boot.\nStep 3. authenticate (interactive only) Skip this step if you are using option B with auth key.\nNavigate to your gokrazy web interface with browser using the URL displayed by gokr-packer. Open the service /user/tailscale and find the login URL. Open the link with browser and log in to Tailscale and authorize the client. Step 4. disable key expiry (optional) You are now connected to Tailscale and you can access your gokrazy instance over Tailscale.\nTailscale requires re-authentication periodically. You can disable key expiry from Tailscale console for the gokrazy instance to not require login every 3 months.\nOptional: tailscale network for other programs (If you only want to connect to services on your gokrazy device, you don‚Äôt need this step.)\nTo make the github.com/stapelberg/dr package able to connect to addresses on the tailscale network, we need to first enable tailscaled‚Äôs HTTP proxy:\necho \u0026#39;--outbound-http-proxy-listen=localhost:9080\u0026#39; \u0026gt;\u0026gt; flags/tailscale.com/cmd/tailscaled/flags.txt And then set the proxy environment variables:\nmkdir -p env/github.com/stapelberg/dr echo \u0026#39;HTTPS_PROXY=localhost:9080\u0026#39; \u0026gt; env/github.com/stapelberg/dr/env.txt echo \u0026#39;HTTP_PROXY=localhost:9080\u0026#39; \u0026gt;\u0026gt; env/github.com/stapelberg/dr/env.txt Optional: Tailscale Go listener If you want to make a program listen on tailscale without listening on any other network interface, you can use the tsnet Tailscale as a library package in your application.\nWhen using tailscale.com/tsnet, you don\u0026rsquo;t need to run tailscale up and it\u0026rsquo;s enough to only include tailscale.com/cmd/tailscaled and your appplication with tsnet.\nThere is an example program at github.com/gokrazy/tsnetdemo:\npackage main import ( \u0026#34;crypto/tls\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;tailscale.com/client/tailscale\u0026#34; \u0026#34;tailscale.com/tsnet\u0026#34; ) func main() { os.Setenv(\u0026#34;TAILSCALE_USE_WIP_CODE\u0026#34;, \u0026#34;true\u0026#34;) // TODO: comment out this line to avoid having to re-login each time you start this program os.Setenv(\u0026#34;TS_LOGIN\u0026#34;, \u0026#34;1\u0026#34;) os.Setenv(\u0026#34;HOME\u0026#34;, \u0026#34;/perm/tsnetdemo\u0026#34;) hostname := flag.String(\u0026#34;hostname\u0026#34;, \u0026#34;tsnetdemo\u0026#34;, \u0026#34;tailscale hostname\u0026#34;) allowedUser := flag.String(\u0026#34;allowed_user\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;the name of a tailscale user to allow\u0026#34;) flag.Parse() s := \u0026amp;tsnet.Server{ Hostname: *hostname, } log.Printf(\u0026#34;starting tailscale listener on hostname %s\u0026#34;, *hostname) ln, err := s.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:443\u0026#34;) if err != nil { log.Fatal(err) } ln = tls.NewListener(ln, \u0026amp;tls.Config{ GetCertificate: tailscale.GetCertificate, }) httpsrv := \u0026amp;http.Server{ Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { who, err := tailscale.WhoIs(r.Context(), r.RemoteAddr) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } if who.UserProfile.LoginName != *allowedUser || *allowedUser == \u0026#34;\u0026#34; { err := fmt.Sprintf(\u0026#34;you are logged in as %q, but -allowed_user flag does not match!\u0026#34;, who.UserProfile.LoginName) log.Printf(\u0026#34;forbidden: %v\u0026#34;, err) http.Error(w, err, http.StatusForbidden) return } fmt.Fprintf(w, \u0026#34;hey there, %q! this message is served via the tsnet package from gokrazy!\u0026#34;, who.UserProfile.LoginName) }), } log.Fatal(httpsrv.Serve(ln)) } Deploy this program to your gokrazy device Open the authentication URL from the log output Open the tsnetdemo host name in your tailscale in your Tailnet domain alias, e.g. https://tsnetdemo.monkey-turtle.ts.net Specify the --allowed_user flag to verify that tailscale authentication works as expected You can also use TS_AUTHKEY instead of TS_LOGIN=1 for non-interactive auth. See Environment variables in Userguide to avoid setting secrets in your application source code.\n"
},
{
	"uri": "https://gokrazy.org/development/gpio/",
	"title": "Controlling a GPIO input/output pin",
	"tags": [],
	"description": "",
	"content": "In this guide, we are using periph.io, a library for peripheral I/O in Go, to set one of the Raspberry Pi‚Äôs General Purpose I/O (GPIO) pins to a logical high (3.3V) or low (0V) signal.\nperiph.io supports the Raspberry Pi 3 and Raspberry Pi 4, starting with version v3.6.4.\nConnect GPIO pins based on pinout To verify the code is doing what we expect, let‚Äôs connect a multimeter as per pinout.xyz‚Äôs pinout:\npin number 18 (signal BCM24, labeled 24 in the pinout above) pin number 20 (signal GND) We need to set the multimeter to ‚ÄúVoltage measurement, DC (direct current)‚Äù.\nSetting an output pin signal To set the pin high and low, alternatingly, with a 5 second frequency, we will be using the hello-gpio program, which is a slightly modified version of the example at periph.io/device/led:\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;periph.io/x/periph/conn/gpio\u0026#34; \u0026#34;periph.io/x/periph/host\u0026#34; \u0026#34;periph.io/x/periph/host/rpi\u0026#34; ) func doGPIO() error { log.Printf(\u0026#34;Loading periph.io drivers\u0026#34;) // Load periph.io drivers: if _, err := host.Init(); err != nil { return err } log.Printf(\u0026#34;Toggling GPIO forever\u0026#34;) t := time.NewTicker(5 * time.Second) for l := gpio.Low; ; l = !l { log.Printf(\u0026#34;setting GPIO pin number 18 (signal BCM24) to %v\u0026#34;, l) // Lookup a pin by its location on the board: if err := rpi.P1_18.Out(l); err != nil { return err } \u0026lt;-t.C } return nil } func main() { if err := doGPIO(); err != nil { log.Fatal(err) } } Install the program on your Raspberry Pi using gokrazy (see Quickstart):\ngokr-packer \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/breakglass \\ github.com/gokrazy/serial-busybox \\ github.com/gokrazy/hello-gpio ‚Ä¶and wait a few seconds for it to reboot.\nAt this point, we should be able to see the high/low signal on the multimeter, alternating between 3.3V (high) and 0V (low) every 5 seconds:\n"
},
{
	"uri": "https://gokrazy.org/userguide/remotesyslog/",
	"title": "Remote Syslog: sending gokrazy logs over the network",
	"tags": [],
	"description": "",
	"content": "If you update your gokrazy installations daily, as we recommend you do, logs will be cleared daily as a side effect of rebooting the device. You can use Remote Syslog to persist logs elsewhere for later analysis.\nClient side (gokrazy) To enable remote syslog, you need to configure a target by creating the file remote_syslog/target on the permanent data partition.\n# The following assumes you already created a file system # on the permanent data partition. Otherwise, please use: # sudo mkfs.ext4 /dev/disk/by-partuuid/2e18c40c-04 sudo mount /dev/disk/by-partuuid/2e18c40c-04 /mnt echo 10.0.0.76:514 | sudo tee /mnt/remote_syslog/target sudo umount /mnt I recommend using a (static) IP address for increased reliability, so that remote syslog works even when DNS does not.\nServer side (syslog-ng) To run a syslog server on gokrazy, check out https://github.com/gokrazy/syslogd.\nIf you want to run your syslog server on a regular Linux distribution, this is how I instructed syslog-ng via its /etc/syslog-ng/syslog-ng.conf to write syslog messages it received from e.g. host gokrazy to /var/log/remote/gokrazy-log:\nsource net { network(ip(10.0.0.76) transport(\u0026#34;udp\u0026#34;)); }; destination remote { file(\u0026#34;/var/log/remote/${FULLHOST}-log\u0026#34;); }; log { source(net); destination(remote); }; "
},
{
	"uri": "https://gokrazy.org/userguide/tls-for-untrusted-networks/",
	"title": "Using TLS in untrusted networks",
	"tags": [],
	"description": "",
	"content": "Let‚Äôs assume that you have installed gokrazy on a Raspberry Pi and are currently successfully updating it over the network like so:\ngokr-packer \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/breakglass \\ github.com/gokrazy/serial-busybox Enabling TLS To start using TLS, specify the -tls=self-signed flag, and set -insecure for the first update:\ngokr-packer \\ -tls=self-signed \\ -insecure \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/breakglass \\ github.com/gokrazy/serial-busybox The gokrazy packer will:\ngenerate a self-signed certificate include the certificate in the gokrazy installation verify the certificate fingerprint in future updates The gokrazy installation will start listening on TCP port 443 for HTTPS connections and redirect any HTTP traffic to HTTPS. When opening the gokrazy web interface in your browser, you will need to explicitly permit communication due to the self-signed certificate.\nFor all future updates, remove the -insecure flag and keep the -tls=self-signed flag:\ngokr-packer \\ -tls=self-signed \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/breakglass \\ github.com/gokrazy/serial-busybox You can now safely update your gokrazy installation over untrusted networks, such as unencrypted WiFi networks.\nDisabling TLS Just remove the -tls flag from your gokr-packer command line. After the next update, gokrazy will no longer contain the certificates and will serve unencrypted HTTP again.\n"
},
{
	"uri": "https://gokrazy.org/development/modules/",
	"title": "Working with Go modules",
	"tags": [],
	"description": "",
	"content": "If you are not yet familiar with Go modules in general (outside of gokrazy), please read the Go wiki page on Modules first.\nSince September 2022, the gokrazy packer builds each package in its own build directory, with its own go.mod and go.sum files. This is done for isolation: if you update one program, that will not have any effect on the other programs you include in your gokrazy instance.\nExample setup Throughout this page, let‚Äôs assume your gokrazy instance directory is ~/gokrazy/scan2drive, and that‚Äôs where you run the following gokr-packer command:\ngokr-packer \\ -update=yes \\ -serial_console=disabled \\ github.com/gokrazy/fbstatus \\ github.com/gokrazy/hello \\ github.com/gokrazy/serial-busybox \\ github.com/stapelberg/scan2drive/cmd/scan2drive The packer will create the following build directory structure:\n% find . -name go.mod ./builddir/init/go.mod ./builddir/github.com/stapelberg/scan2drive/cmd/scan2drive/go.mod ./builddir/github.com/gokrazy/serial-busybox/go.mod ./builddir/github.com/gokrazy/hello/go.mod ./builddir/github.com/gokrazy/fbstatus/go.mod ./builddir/github.com/gokrazy/gokrazy/go.mod ./builddir/github.com/gokrazy/gokrazy/cmd/randomd/go.mod ./builddir/github.com/gokrazy/gokrazy/cmd/ntp/go.mod ./builddir/github.com/gokrazy/gokrazy/cmd/dhcp/go.mod ./builddir/github.com/gokrazy/rpi-eeprom/go.mod ./builddir/github.com/gokrazy/firmware/go.mod ./builddir/github.com/gokrazy/kernel/go.mod You can see that there is one subdirectory for each package explicitly specified on the command line, plus a couple extra ones that gokrazy always installs, e.g. github.com/gokrazy/gokrazy/cmd/dhcp.\nTop-level go.mod template If you want to influence the content of any newly created go.mod (no effect on existing go.mod files), you can create a go.mod template in your instance directory: ~/gokrazy/scan2drive/go.mod.\nBuilding local code: the replace directive Go modules are loaded from the internet by default and are stored read-only on disk.\nIf you want to make the gokrazy packer pick up a local working copy with your own changes instead, use the replace directive:\n# Create a local working copy in whichever directory you like. % cd ~/projects % git clone https://github.com/stapelberg/scan2drive % cd scan2drive # make some changes # Switch to your gokrazy instance directory, # ‚Ä¶and specifically to the scan2drive build directory, # to add a replace directive to go.mod: % cd ~/gokrazy/scan2drive % cd builddir/github.com/stapelberg/scan2drive/cmd/scan2drive % go mod edit -replace \\ github.com/stapelberg/scan2drive=/home/michael/projects/scan2drive For more details on the replace directive, see the Go wiki.\nInfluencing the granularity Often, one Go package will be the only package you use from a certain Go module. But this isn‚Äôt always the case: for example, the system packages github.com/gokrazy/gokrazy/cmd/dhcp and github.com/gokrazy/gokrazy/cmd/ntp both come from the github.com/gokrazy/gokrazy module.\nThe packer will by default create a separate builddir, including a separate go.mod and go.sum, for each package, even when they come from the same module.\nIf you want to add module-wide replace directives to your go.mod file, you can influence the granularity at which gokr-packer works as follows.\nMove the go.mod/go.sum files to the directory level within the builddir/ hierarchy at which you would like to work. gokr-packer will look for go.mod/go.sum files at the package level, going one level up until it finds the files.\nHence, you can use the following locations, ordered from finest to coarsest granularity:\nper-package builddir (default), e.g.: builddir/github.com/gokrazy/gokrazy/cmd/dhcp/go.mod\nper-module builddir (convenient when working with replace directives), e.g.: builddir/github.com/gokrazy/gokrazy/go.mod\nper-org builddir (convenient for wide-reaching replace directives), e.g.: builddir/github.com/gokrazy/go.mod\nsingle builddir, preserving the previous behavior, e.g.: builddir/go.mod\n"
},
{
	"uri": "https://gokrazy.org/packages/caddy-http-server/",
	"title": "Caddy HTTP server",
	"tags": [],
	"description": "",
	"content": "Caddy is a powerful, enterprise-ready, open source web server with automatic HTTPS written in Go.\nStep 1: Configuring the Caddyfile and flags Tell caddy to run its HTTP server, and where to find its Caddyfile:\nmkdir -p flags/github.com/caddyserver/caddy/v2/cmd/caddy cat \u0026gt; flags/github.com/caddyserver/caddy/v2/cmd/caddy/flags.txt \u0026lt;\u0026lt;\u0026#39;EOT\u0026#39; run --config /etc/caddy/Caddyfile EOT Include the config file in the gokrazy image at /etc/caddy/Caddyfile:\nmkdir -p extrafiles/github.com/caddyserver/caddy/v2/cmd/caddy/etc/caddy cat \u0026gt; extrafiles/github.com/caddyserver/caddy/v2/cmd/caddy/etc/caddy/Caddyfile \u0026lt;\u0026lt;\u0026#39;EOT\u0026#39; http://:80 { root * /tmp file_server browse } EOT Note: In the above Caddyfile, we have explicitly configured an HTTP listener to disable Caddy‚Äôs automatic HTTPS setup, so that your server will work without a publically reachable address.\nStep 2: Install Caddy to your gokrazy device In your gokr-packer invocation (see Quickstart if you don‚Äôt have one yet):\ninclude the caddy package set the -http_port flag to move the gokrazy web interface listening port out of the way and let caddy serve on TCP port 80. The special -update=:80 syntax is the same as -update=yes, but forcing this update to happen via port 80. In later gokr-packer runs, use -update=yes instead. gokr-packer \\ -update=:80 \\ -http_port=1080 \\ github.com/gokrazy/hello \\ github.com/gokrazy/breakglass \\ github.com/gokrazy/serial-busybox \\ github.com/caddyserver/caddy/v2/cmd/caddy Tip: When using breakglass, use the -gokrazy_url=:1080 flag to overwrite the port.\n"
},
{
	"uri": "https://gokrazy.org/userguide/wifi/",
	"title": "Connecting to WiFi networks",
	"tags": [],
	"description": "",
	"content": "Since March 2022, gokrazy supports both encrypted and unencrypted WiFi networks! üéâ\nRemember that using an unencrypted WiFi network means anyone in range can read your communication. Hence, we strongly recommend using TLS for accessing the gokrazy web interface and doing updates.\nTo make gokrazy connect to a WiFi network, first include the github.com/gokrazy/wifi package in your gokr-packer command line, e.g.:\ngokr-packer \\ -tls=self-signed \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/breakglass \\ github.com/gokrazy/serial-busybox \\ github.com/gokrazy/wifi Then, configure the wifi program by creating the file wifi.json as extra file:\nmkdir -p extrafiles/github.com/gokrazy/wifi/etc/ # To connect to an unencrypted WiFi network, specify no psk: echo \u0026#39;{\u0026#34;ssid\u0026#34;: \u0026#34;My unencrypted WiFi\u0026#34;}\u0026#39; \\ \u0026gt; extrafiles/github.com/gokrazy/wifi/etc/wifi.json # OR, to connect to an encrypted WiFi network, specify the psk: echo \u0026#39;{\u0026#34;ssid\u0026#34;: \u0026#34;Secure WiFi\u0026#34;, \u0026#34;psk\u0026#34;: \u0026#34;secret\u0026#34;}\u0026#39; \\ \u0026gt; extrafiles/github.com/gokrazy/wifi/etc/wifi.json Alternatively, you can also create the wifi.json manually on the permanent data partition with path /perm/wifi.json.\nAfter starting gokrazy, the wifi program will connect to the configured WiFi network:\nFor debugging: known-working WiFi router setup In case you have trouble getting your Raspberry Pi to connect to your network, this is how I set up my TP-LINK TL-WDR4300 with OpenWrt 19.07:\nThe MAC address filter isn‚Äôt a security measure, but prevents others from accidentally joining this open network.\n"
},
{
	"uri": "https://gokrazy.org/userguide/bluetooth/",
	"title": "Using Bluetooth",
	"tags": [],
	"description": "",
	"content": "gokrazy has limited support for Bluetooth. The usual Bluetooth utilities (bluez) have a lot of dependencies that are not available on gokrazy and those are out of scope here. But the basic Bluetooth hardware are supported on low level. This is useful in particular for applications using Bluetooth LE natively in Go.\nTo enable Bluetooth in gokrazy, first include the github.com/gokrazy/bluetooth package in your gokr-packer command line, e.g.:\ngokr-packer \\ -tls=self-signed \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/bluetooth The github.com/gokrazy/bluetooth package loads the appropriate kernel modules and firmware required.\nExample program As demo we\u0026rsquo;re using bluewalker Bluetooth LE scanner utility just to show that Bluetooth is working.\nFirst, prepare command line flags.\nmkdir -p flags/gitlab.com/jtaimisto/bluewalker echo \u0026#39;-device=hci0\u0026#39; \u0026gt; flags/gitlab.com/jtaimisto/bluewalker/flags.txt Then, deploy as usual.\ngokr-packer \\ -tls=self-signed \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/bluetooth \\ gitlab.com/jtaimisto/bluewalker Once deployed with gokr-packer, you can see Bluetooth events being received in the bluewalker output.\n"
},
{
	"uri": "https://gokrazy.org/userguide/permanent-data/",
	"title": "Access permanent data",
	"tags": [],
	"description": "",
	"content": "Create the filesystem gokrazy provides a handy way to create the permanent data filesystem on the fourth partition of your gokrazy installation. The gokrazy/mkfs program will create the filesystem. To actually access the permanent data partition from your own program, gokrazy will mount the partition under /perm directory during the startup.\nYou can either include this program in your gokr-packer command line:\ngokr-packer \\ -overwrite=/dev/sdx \\ -serial_console=disabled \\ github.com/gokrazy/fbstatus \\ github.com/gokrazy/hello \\ github.com/gokrazy/serial-busybox \\ github.com/gokrazy/mkfs ‚Ä¶or, if you want to run it only once without otherwise including it in your installation, you can use gok run:\ngit clone https://github.com/gokrazy/mkfs cd mkfs gok run -i bakery Permanent data in action The Go program demonstrates the functionality of the permanent data mount:\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; ) const config = \u0026#34;/perm/my-example/config.json\u0026#34; type Config struct { FilesToCreate int `json:\u0026#34;files_to_create\u0026#34;` } func main() { _, err := os.Stat(config) if err != nil { fsErr := \u0026amp;fs.ErrNotExist if !errors.As(err, fsErr) { panic(err) } content, err := json.Marshal(\u0026amp;Config{FilesToCreate: 4}) if err != nil { panic(err) } if err = ioutil.WriteFile(config, content, 0600); err != nil { panic(err) } } content, err := ioutil.ReadFile(config) if err != nil { panic(err) } var c Config if err := json.Unmarshal(content, \u0026amp;c); err != nil { panic(err) } for i := 0; i \u0026lt; c.FilesToCreate; i++ { if err := ioutil.WriteFile(fmt.Sprintf(\u0026#34;/perm/my-example/%d.txt\u0026#34;, i), []byte(\u0026#34;gokrazy rocks\u0026#34;), 0600); err != nil { panic(err) } } } Manual inspection/modification You can inspect and modify the data on the permanent data filesystem manually. This can be handy if you need e.g. to pass a configuration file for your application. To access the filesystem put the SD card into your PC/notebook. Your OS will likely mount the filesystem automatically. Copy the file to the permanent data filesystem.\nmkdir /path/to-mounted/filesystem/my-example sudo cp config.json /path/to-mounted/filesystem/my-example If you want to access files on the permanent data filesystem you may need the sudo capability.\n"
},
{
	"uri": "https://gokrazy.org/packages/minio/",
	"title": "MinIO object storage",
	"tags": [],
	"description": "",
	"content": "MinIO is high-performance object storage that is API compatible to Amazons Simple Storage Service (S3), but is open source and written in Go. It can be used as a building block for applications involving file storage and file transmission and while its native to the cloud, it turns out one can also use it on gokrazy. :)\nSince MinIO is a storage solution, you need to enable permanent storage on your gokrazy installation by running the mkfs command that gokr-packer prints. For more details, see Quickstart.\nThis article also assumes that you have an instance directory (with a go.mod) set up.\nStep 1: Configuring the environment variables and command-line flags You can find a detailed description on how to set the flags and environment vars in the article per-package configuration.\n${INSTANCE?}/env/github.com/minio/minio/env.txt\nMINIO_ROOT_USER=minio MINIO_ROOT_PASSWORD=minio-on-gokrazy ${INSTANCE?}/flags/github.com/minio/minio/flags.txt\nserver --address :3001 --console-address :3002 /perm/minio/ A few things can be noted here:\nThere are nice practical examples on the different options once you execute minio server --help if you have it installed locally or more advanced use cases in the official MinIO docs.\nThe ports for the storage server and console do not have to be explicitly set, but for me the default port collided with another service (Port 9000). If no port is set the console just chooses an arbitrary free one.\nFor some reason the HOME variable has to be set to the storage folder. See Issue #12641 on why that is the case. As default gokrazy sets HOME to HOME=/perm/\u0026lt;cmd\u0026gt;, so if you want to change your storage location to something different modify the env.txt accordingly.\nStep 2: Install MinIO to your gokrazy device In your gokr-packer invocation (see Quickstart if you don‚Äôt have one yet), include the MinIO package:\ngokr-packer \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/breakglass \\ github.com/gokrazy/serial-busybox \\ github.com/minio/minio Step 3: Test whether the setup was successful If you have the mc command installed you can check out whether your installation of MinIO really works:\n$ mc alias set gokrazy http://gokrazy:3001 minio minio-on-gokrazy Added `gokrazy` successfully. $ mc ls gokrazy $ mc mb gokrazy/testbucket Bucket created successfully `gokrazy/testbucket`. $ mc ls gokrazy [2021-09-15 16:40:16 CEST] 0B testbucket/ Also check out the output in the logs on the gokrazy webinterface and login into the MinIO management console (http://gokrazy:3002 in this guide) to create service accounts view logs, bucket contents and more.\n"
},
{
	"uri": "https://gokrazy.org/userguide/rsync-backups/",
	"title": "Permanent data backup with the gokrazy rsyncd",
	"tags": [],
	"description": "",
	"content": "I like to periodically back up all scans from my scan2drive appliance to my PC. The PC is backed up as well, so that automatically distributes my scans to multiple machines in case one of them fails.\nA convenient way to set up an efficient partial or full backup of a gokrazy device‚Äôs permanent data partition is to use the gokrazy rsync daemon. This article walks you through how I have set up my backup, but many variants are possible to cater to different requirements.\n(You don‚Äôt typically need backups of your gokrazy device‚Äôs root partition because it can be built reproducibly any time using Go.)\nStep 1. Configure the gokrazy rsync daemon In your gokrazy instance directory (see Quickstart if you don‚Äôt have one yet), create a package flag config file to start gokrazy rsync as a daemon:\nmkdir -p flags/github.com/gokrazy/rsync/cmd/gokr-rsyncd cat \u0026gt; flags/github.com/gokrazy/rsync/cmd/gokr-rsyncd/flags.txt \u0026lt;\u0026lt;\u0026#39;EOT\u0026#39; --gokr.config=/etc/gokr-rsyncd.toml --daemon EOT In the daemon config file, configure an authorized SSH listener and which rsync modules to serve:\nmkdir -p extrafiles/github.com/gokrazy/rsync/cmd/gokr-rsyncd/etc cat \u0026gt; extrafiles/github.com/gokrazy/rsync/cmd/gokr-rsyncd/etc/gokr-rsyncd.toml \u0026lt;\u0026lt;\u0026#39;EOT\u0026#39; dont_namespace = true [[listener]] [listener.authorized_ssh] address = \u0026#34;scan2drive.lan:22873\u0026#34; authorized_keys = \u0026#34;/etc/gokr-rsyncd.authorized_keys\u0026#34; [[module]] name = \u0026#34;scans\u0026#34; path = \u0026#34;/perm/scans\u0026#34; EOT Finally, create the authorized keys file that determines who can access the rsync daemon:\ncat \u0026gt; extrafiles/github.com/gokrazy/rsync/cmd/gokr-rsyncd/etc/gokr-rsyncd.authorized_keys \u0026lt;\u0026lt;\u0026#39;EOT\u0026#39; ssh-ed25519 [‚Ä¶] michael@midna EOT Step 2. Install the gokrazy rsync daemon Include the gokrazy rsync daemon gokr-rsyncd in your gokr-packer invocation, for example:\ngokr-packer \\ -update=yes \\ -serial_console=disabled \\ github.com/gokrazy/fbstatus \\ github.com/gokrazy/hello \\ github.com/gokrazy/serial-busybox \\ github.com/gokrazy/rsync/cmd/gokr-rsyncd Step 3. Configure SSH from the backup machine On your PC (not the gokrazy instance), add an SSH configuration stanza to your ~/.ssh/config to configure the custom port (22873 for ssh+rsync) and which passwordless identity file to use (for the cron job in step 4):\nHost scan2drive-backup Hostname scan2drive.lan Port 22873 IdentityFile ~/.ssh/id_ed25519_scan2drivebackup Now you should be able to run rsync via SSH as usual:\nrsync -av -e ssh rsync://scan2drive-backup/scans/ ~/scan2drive-backup/ Step 4. Configure a daily cron job First, install the rsync-prom tool to monitor your periodic transfer with Prometheus:\ngo install github.com/stapelberg/rsyncprom/cmd/rsync-prom@latest Then wrap the above rsync command in an rsync-prom invocation in a shell script called scan2drive-backup-sync.sh:\n#!/bin/sh SSH_AUTH_SOCK= ~/go/bin/rsync-prom --instance=\u0026#34;scan2drive@midna\u0026#34; \\ rsync -av -e ssh rsync://scan2drive-backup/scans/ ~/scan2drive-backup/ Finally, run crontab -e and run the script at your convenience, like so:\n30 07 * * * /home/michael/scan2drive-backup-sync.sh "
},
{
	"uri": "https://gokrazy.org/packages/docker-containers/",
	"title": "Docker containers",
	"tags": [],
	"description": "",
	"content": "gokrazy‚Äôs goal is to make it easy to build Go appliances. In an ideal world, all building blocks you need would be available in Go. In reality, that is not entirely the case. Perhaps you need to run a C program next to your Go programs. Docker containers make incremental (or partial) adoption of gokrazy easy.\nWe‚Äôre going to use podman, a drop-in replacement for Docker, because there is a statically compiled version for amd64 and arm64 available that we could easily re-package into https://github.com/gokrazy/podman.\nStep 1: Install podman to your gokrazy device In your gokr-packer invocation (see Quickstart if you don‚Äôt have one yet), include the iptables, nsenter and podman packages:\ngokr-packer \\ -update=yes \\ github.com/gokrazy/hello \\ github.com/gokrazy/breakglass \\ github.com/gokrazy/serial-busybox \\ github.com/gokrazy/iptables \\ github.com/gokrazy/nsenter \\ github.com/gokrazy/podman \\ github.com/greenpau/cni-plugins/cmd/cni-nftables-portmap \\ github.com/greenpau/cni-plugins/cmd/cni-nftables-firewall Step 2: Verify podman works Use breakglass to login to your gokrazy instance and run a container manually:\n/tmp/breakglass187145741 $ mount -t tmpfs tmpfs /var /tmp/breakglass187145741 $ podman run --rm -ti docker.io/library/debian:sid root@gokrazy:/# cat /etc/debian_version bookworm/sid Step 3: Use podman programmatically Now that you have the required tools, there are a couple of decisions you have to make depending on what you want to run in your container(s):\nShould container data be stored ephemerally in tmpfs (lost with the next reboot), on the permanent partition of your SD card, or somewhere else entirely (e.g. network storage)? Do you want to pull new container versions automatically before each run, or manually on demand only? Should your container be started as a one-off job only (‚Üí detached mode), or supervised continuously (restarted when it exits)? Should your container use a deterministic name (so that you can exec commands in it easily), or use a fresh name for each run (so that there never are conflicts)? Aside from these broad questions, you very likely need to set a bunch of detail options for your container, such as additional environment variables, volume mounts, networking flags, or command line arguments.\nThe following program is an example for how this could look like. I use this program to run irssi.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;github.com/gokrazy/gokrazy\u0026#34; ) func podman(args ...string) error { podman := exec.Command(\u0026#34;/usr/local/bin/podman\u0026#34;, args...) podman.Env = expandPath(os.Environ()) podman.Env = append(podman.Env, \u0026#34;TMPDIR=/tmp\u0026#34;) podman.Stdin = os.Stdin podman.Stdout = os.Stdout podman.Stderr = os.Stderr if err := podman.Run(); err != nil { return fmt.Errorf(\u0026#34;%v: %v\u0026#34;, podman.Args, err) } return nil } func irssi() error { // Ensure we have an up-to-date clock, which in turn also means that // networking is up. This is relevant because podman takes what‚Äôs in // /etc/resolv.conf (nothing at boot) and holds on to it, meaning your // container will never have working networking if it starts too early. gokrazy.WaitForClock() if err := mountVar(); err != nil { return err } if err := podman(\u0026#34;kill\u0026#34;, \u0026#34;irssi\u0026#34;); err != nil { log.Print(err) } if err := podman(\u0026#34;rm\u0026#34;, \u0026#34;irssi\u0026#34;); err != nil { log.Print(err) } // You could podman pull here. if err := podman(\u0026#34;run\u0026#34;, \u0026#34;-td\u0026#34;, \u0026#34;-v\u0026#34;, \u0026#34;/perm/irssi:/home/michael/.irssi\u0026#34;, \u0026#34;-v\u0026#34;, \u0026#34;/perm/irclogs:/home/michael/irclogs\u0026#34;, \u0026#34;-e\u0026#34;, \u0026#34;TERM=rxvt-unicode\u0026#34;, \u0026#34;-e\u0026#34;, \u0026#34;LANG=C.UTF-8\u0026#34;, \u0026#34;--network\u0026#34;, \u0026#34;host\u0026#34;, \u0026#34;--name\u0026#34;, \u0026#34;irssi\u0026#34;, \u0026#34;docker.io/stapelberg/irssi:latest\u0026#34;, \u0026#34;screen\u0026#34;, \u0026#34;-S\u0026#34;, \u0026#34;irssi\u0026#34;, \u0026#34;irssi\u0026#34;); err != nil { return err } return nil } func main() { if err := irssi(); err != nil { log.Fatal(err) } } // mountVar bind-mounts /perm/container-storage to /var if needed. // This could be handled by an fstab(5) feature in gokrazy in the future. func mountVar() error { b, err := os.ReadFile(\u0026#34;/proc/self/mountinfo\u0026#34;) if err != nil { return err } for _, line := range strings.Split(strings.TrimSpace(string(b)), \u0026#34;\\n\u0026#34;) { parts := strings.Fields(line) if len(parts) \u0026lt; 5 { continue } mountpoint := parts[4] log.Printf(\u0026#34;Found mountpoint %q\u0026#34;, parts[4]) if mountpoint == \u0026#34;/var\u0026#34; { log.Printf(\u0026#34;/var file system already mounted, nothing to do\u0026#34;) return nil } } if err := syscall.Mount(\u0026#34;/perm/container-storage\u0026#34;, \u0026#34;/var\u0026#34;, \u0026#34;\u0026#34;, syscall.MS_BIND, \u0026#34;\u0026#34;); err != nil { return fmt.Errorf(\u0026#34;mounting /perm/container-storage to /var: %v\u0026#34;, err) } return nil } // expandPath returns env, but with PATH= modified or added // such that both /user and /usr/local/bin are included, which podman needs. func expandPath(env []string) []string { extra := \u0026#34;/user:/usr/local/bin\u0026#34; found := false for idx, val := range env { parts := strings.Split(val, \u0026#34;=\u0026#34;) if len(parts) \u0026lt; 2 { continue // malformed entry } key := parts[0] if key != \u0026#34;PATH\u0026#34; { continue } val := strings.Join(parts[1:], \u0026#34;=\u0026#34;) env[idx] = fmt.Sprintf(\u0026#34;%s=%s:%s\u0026#34;, key, extra, val) found = true } if !found { const busyboxDefaultPATH = \u0026#34;/usr/local/sbin:/sbin:/usr/sbin:/usr/local/bin:/bin:/usr/bin\u0026#34; env = append(env, fmt.Sprintf(\u0026#34;PATH=%s:%s\u0026#34;, extra, busyboxDefaultPATH)) } return env } "
},
{
	"uri": "https://gokrazy.org/development/non-go/",
	"title": "Non-Go Prototyping",
	"tags": [],
	"description": "",
	"content": "To realize the full benefits of gokrazy, you need to use only software written in Go. If there is no Go software for what you want to do, creating that piece of software can pose a seemingly unsurmountable hurdle. To make some quick progress and figure out if your idea can be implemented, it might make sense to temporarily use existing software before starting your own implementation.\nThis article shows a couple of techniques for getting non-Go software to work on gokrazy, in increasing order of complexity.\nNote that software which is manually installed like shown here will not be automatically updated by gokrazy and hence poses a security risk. Use these techniques only for prototyping.\nGo software not written for gokrazy: Grafana It would not suffice to add Grafana to your gokr-packer command, as the resulting Grafana binary requires assets, supports plugins, keeps state, etc.\nHence, you need to manually install Grafana into a directory underneath /perm. A convenient way to do that is to use breakglass to download the ‚ÄúStandalone Linux Binaries‚Äù release from https://grafana.com/grafana/download?platform=arm. Note that I am serving the file from my computer because my busybox version supports neither HTTPS nor DNS.\n/tmp/breakglass531810560 # wget http://10.0.0.76:4080/grafana-5.3.2.linux-arm64.tar.gz /tmp/breakglass531810560 # tar xf grafana-5.3.2.linux-arm64.tar.gz We cannot start Grafana yet, as its binary is dynamically linked. One way to fix this is to place the sources which correspond to the release you just unpacked (e.g. from https://github.com/grafana/grafana/tree/v5.3.2) in your $GOPATH and recompile the binaries:\nGOARCH=arm64 CGO_ENABLED=1 CC=aarch64-linux-gnu-gcc go install \\ -ldflags \u0026#34;-linkmode external -extldflags -static\u0026#34; \\ github.com/grafana/grafana/pkg/cmd/... Note that it is usually easier to set the environment variable CGO_ENABLED=0 to get a statically linked binary, but Grafana uses sqlite3, which is written in C, so we resort to the -ldflags variant.\nAt this point, we can start Grafana from breakglass:\n/tmp/breakglass531810560 # cd grafana-5.3.2 /tmp/breakglass531810560/grafana-5.3.2 # wget http://10.0.0.76:4080/grafana-server /tmp/breakglass531810560/grafana-5.3.2 # install -m 755 grafana-server bin/ \u0026amp;\u0026amp; rm grafana-server /tmp/breakglass531810560/grafana-5.3.2 # ./bin/grafana-server INFO[10-30|19:27:51] Starting Grafana logger=server version=5.0.0 commit=NA compiled=2018-10-30T19:27:51+0100 ‚Ä¶ To have gokrazy start Grafana, we can use a Go package like this:\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { const bin = \u0026#34;/perm/grafana/bin/grafana-server\u0026#34; if err := syscall.Exec(bin, []string{bin, \u0026#34;-homepath=/perm/grafana\u0026#34;}, nil); err != nil { log.Fatal(err) } } C software: WireGuard WireGuard is a modern VPN tunnel, which consists of a Linux kernel module and a configuration tool. See rtr7/kernel@c7afbc1f for how the kernel module was added to the router7 kernel.\nThe configuration tool can be statically cross-compiled. We can run Debian in a Docker container to not mess with our host system:\n% mkdir /tmp/wg % cd /tmp/wg % docker run -t -i debian root@d1728eaaa6e1:/# dpkg --add-architecture arm64 root@d1728eaaa6e1:/# apt update root@d1728eaaa6e1:/# apt install libmnl-dev:arm64 libelf-dev:arm64 linux-headers-amd64 crossbuild-essential-arm64 pkg-config wget root@d1728eaaa6e1:/# wget https://git.zx2c4.com/WireGuard/snapshot/WireGuard-0.0.20181018.tar.xz root@d1728eaaa6e1:/# tar xf WireGuard-0.0.20181018.tar.xz root@d1728eaaa6e1:/# cd WireGuard-0.0.20181018/src/tools root@d1728eaaa6e1:/# make CC=aarch64-linux-gnu-gcc LDFLAGS=-static root@d1728eaaa6e1:/# exit % docker cp -L d1728eaaa6e1:/WireGuard-0.0.20181018/src/tools/wg . Now we can copy and run the wg binary via breakglass:\n/tmp/breakglass531810560 # wget http://10.0.0.76:4080/wg /tmp/breakglass531810560 # chmod +x wg /tmp/breakglass531810560 # ./wg --help Usage: ./wg \u0026lt;cmd\u0026gt; [\u0026lt;args\u0026gt;] ‚Ä¶ C software: tc Linux‚Äôs Traffic Control system (used e.g. for traffic shaping) is configured with the tc tool.\ntc is a special case in that it requires to be dynamically linked. The different queueing disciplines are implemented as plugins, and statically linking tc results in a binary which starts but won‚Äôt be able to display or change queueing disciplines.\nBecause gokrazy doesn‚Äôt include a C runtime environment, we‚Äôll need to copy not only the tc binary, but also the dynamic loader and all required shared libraries. We can run Debian in a Docker container to not mess with our host system, and use the freeze tool to automate the tedious parts of the process:\n% mkdir /tmp/iproute % cd /tmp/iproute % docker run -t -i debian:bookworm root@6e530a973d45:/# dpkg --add-architecture arm64 root@6e530a973d45:/# apt update root@6e530a973d45:/# apt install iproute2:arm64 qemu-user-static golang-go ca-certificates root@6e530a973d45:/# go install github.com/gokrazy/freeze/cmd/...@latest root@6e530a973d45:/# ~/go/bin/freeze -wrap=qemu-aarch64-static $(which tc) 2022/03/20 11:45:46 /sbin/tc 2022/03/20 11:45:46 Copying tc together with its 12 ELF shared library dependencies 2022/03/20 11:45:46 [cp /sbin/tc /tmp/freeze2237965672/tc] 2022/03/20 11:45:46 [cp /usr/lib/aarch64-linux-gnu/libbpf.so.0.7.0 /tmp/freeze2237965672/libbpf.so.0] 2022/03/20 11:45:46 [cp /usr/lib/aarch64-linux-gnu/libelf-0.186.so /tmp/freeze2237965672/libelf.so.1] 2022/03/20 11:45:46 [cp /usr/lib/aarch64-linux-gnu/libmnl.so.0.2.0 /tmp/freeze2237965672/libmnl.so.0] 2022/03/20 11:45:46 [cp /usr/lib/aarch64-linux-gnu/libbsd.so.0.11.5 /tmp/freeze2237965672/libbsd.so.0] 2022/03/20 11:45:46 [cp /lib/aarch64-linux-gnu/libcap.so.2.44 /tmp/freeze2237965672/libcap.so.2] 2022/03/20 11:45:46 [cp /lib/aarch64-linux-gnu/libm-2.33.so /tmp/freeze2237965672/libm.so.6] 2022/03/20 11:45:46 [cp /lib/aarch64-linux-gnu/libdl-2.33.so /tmp/freeze2237965672/libdl.so.2] 2022/03/20 11:45:46 [cp /usr/lib/aarch64-linux-gnu/libxtables.so.12.4.0 /tmp/freeze2237965672/libxtables.so.12] 2022/03/20 11:45:46 [cp /lib/aarch64-linux-gnu/libc-2.33.so /tmp/freeze2237965672/libc.so.6] 2022/03/20 11:45:46 [cp /lib/aarch64-linux-gnu/ld-2.33.so /tmp/freeze2237965672/ld-linux-aarch64.so.1] 2022/03/20 11:45:46 [cp /lib/aarch64-linux-gnu/libz.so.1.2.11 /tmp/freeze2237965672/libz.so.1] 2022/03/20 11:45:46 [cp /usr/lib/aarch64-linux-gnu/libmd.so.0.0.5 /tmp/freeze2237965672/libmd.so.0] 2022/03/20 11:45:46 [tar cf /tmp/freeze2237965672.tar freeze2237965672] 2022/03/20 11:45:46 Download freeze2237965672.tar to your gokrazy device and run: LD_LIBRARY_PATH=$PWD ./ld-linux-aarch64.so.1 ./tc root@6e530a973d45:/# exit % mkdir /tmp/freeze % cd /tmp/freeze % docker cp 6e530a973d45:/tmp/freeze2237965672.tar . % caddy file-server -listen=:4080 Now we can copy the contents of the temporary directory to e.g. /perm/tc and run the tc command in breakglass:\n/tmp/breakglass531810560 # wget -O- http://10.0.0.76:4080/freeze2237965672.tar | tar xf - /tmp/breakglass531810560 # cd freeze2237965672 /tmp/breakglass531810560/freeze2237965672 # LD_LIBRARY_PATH=$PWD ./ld-linux-aarch64.so.1 ./tc Usage: tc [ OPTIONS ] OBJECT { COMMAND | help } ‚Ä¶ "
},
{
	"uri": "https://gokrazy.org/",
	"title": "gokrazy",
	"tags": [],
	"description": "",
	"content": "gokrazy Go appliances With gokrazy, you can deploy your Go programs as appliances to a Raspberry Pi or PC (‚Üí supported platforms).\nFor a long time, we were unhappy with having to care about security issues and Linux distribution maintenance on our various Raspberry Pis.\nThen, we had a crazy idea: what if we got rid of memory-unsafe languages and all software we don‚Äôt strictly need?\nTurns out this is feasible. gokrazy is the result.\nYour app(s) + only 4 moving parts the Linux kernel the Raspberry Pi firmware files the Go compiler and standard library the gokrazy userland All are updated using the same command.\nWeb status interface On a regular Linux distribution, we‚Äôd largely use systemctl‚Äôs start, stop, restart and status verbs to manage our applications. gokrazy comes with a convenient web interface for seeing process status and stopping/restarting processes.\nDebugging Sometimes, an interactive busybox session or a quick tcpdump run are invaluable. breakglass allows you to temporarily enable SSH/SCP-based authenticated remote code execution: scp your statically compiled binary, then run it interactively via ssh.\nDue to no C runtime environment being present, your code must compile with the environment variable CGO_ENABLED=0. To cross-compile for the Raspberry Pi 3 or 4, use GOARCH=arm64. If your program still builds, you‚Äôre good to go!\nNetwork updates After building a new gokrazy image on your computer, you can easily update an existing gokrazy installation in-place thanks to the A/B partitioning scheme we use. Just specify the -update flag when building your new image.\nMinimal state and configuration A tiny amount of configuration is built into the images (e.g. hostname, password, serial console behavior). In general, we prefer auto-configuration (e.g. DHCP) over config files. If you need more configurability, you may need to replace some of our programs.\n"
}]